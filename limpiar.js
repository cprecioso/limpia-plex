// Generated by CoffeeScript 1.10.0
(function() {
  var path, pkginfo, program, shell, trash,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  path = require("path");

  shell = require("shelljs");

  shell.config.silent = true;

  program = require("commander");

  pkginfo = require("./package.json");

  trash = require("trash");

  require("colors");

  Promise.prototype.tap = function(f) {
    return this.then(function(v) {
      return (function(v) {
        return Promise.resolve(f(v)).then((function() {
          return v;
        }), (function() {
          return v;
        }));
      })(v);
    });
  };

  exports.run = function(argv) {
    var assess, confirm, inform, parse, remove;
    parse = exports.parse, assess = exports.assess, inform = exports.inform, confirm = exports.confirm, remove = exports.remove;
    return Promise.resolve(argv).then(parse).then(assess).tap(function(v) {
      return inform(v).then(confirm).then(function(apply) {
        if (!apply) {
          return process.exit();
        }
      });
    }).then(remove).then(function() {
      console.log("Success!".green);
      return process.exit(0);
    }, function(e) {
      console.error("Error!".red);
      if (e) {
        console.error(e);
      }
      return process.exit(1);
    });
  };

  exports.parse = function(argv) {
    return new Promise(function(fulfill, reject) {
      var args, debug, extensions, exts, ref, verbose;
      exts = "mp4,m4v,mkv,avi,part,torrent";
      program._name = pkginfo.name;
      ref = program.version(pkginfo.version).description(pkginfo.description)["arguments"]("<dirs...>").option("-v, --verbose", "Enable verbose mode").option("-d, --debug", "Enable debug mode").option("-e, --extensions [exts]", "Extensions to consider as video. Default: " + exts, (function(exts) {
        return exts.trim().split(",");
      })).parse(argv), args = ref.args, extensions = ref.extensions, verbose = ref.verbose, debug = ref.debug;
      return fulfill({
        dirs: (args != null ? args.length : void 0) > 0 ? args : (program.outputHelp(), reject("Please specify the Plex library folder(s)")),
        exts: (extensions != null ? extensions.length : void 0) > 0 ? extensions : exts.split(","),
        verbose: !!verbose,
        debug: !!debug
      });
    });
  };

  exports.assess = function(opts) {
    return new Promise(function(fulfill) {
      var data, dirs, error, exts, folder, i, keep, len, lsResult, reason, rootFolder;
      dirs = opts.dirs, exts = opts.exts;
      data = {};
      for (i = 0, len = dirs.length; i < len; i++) {
        rootFolder = dirs[i];
        rootFolder = path.resolve(rootFolder);
        lsResult = shell.ls(rootFolder);
        if (error = shell.error()) {
          throw error;
        }
        data[path.basename(rootFolder)] = (function() {
          var j, len1, ref, results1;
          results1 = [];
          for (j = 0, len1 = lsResult.length; j < len1; j++) {
            folder = lsResult[j];
            folder = path.resolve(rootFolder, folder);
            ref = (function() {
              var extension, file, k, len2, lfile, ls2Result;
              ls2Result = shell.ls("-R", folder);
              if (error = shell.error()) {
                throw error;
              }
              for (k = 0, len2 = ls2Result.length; k < len2; k++) {
                file = ls2Result[k];
                lfile = file.toLowerCase();
                extension = path.extname(lfile).slice(1);
                if (lfile.includes("sample")) {
                  continue;
                }
                if (indexOf.call(exts, extension) >= 0) {
                  return [true, path.basename(file)];
                }
              }
              return [false];
            })(), keep = ref[0], reason = ref[1];
            results1.push([folder, !!keep, reason]);
          }
          return results1;
        })();
      }
      return fulfill([opts, data]);
    });
  };

  exports.inform = function(arg) {
    var opts, report;
    opts = arg[0], report = arg[1];
    return new Promise(function(fulfill) {
      var _, actionNeeded, contents, debug, files, folder, i, j, keep, len, len1, library, reason, ref, ref1, results, verbose;
      actionNeeded = false;
      verbose = opts.verbose, debug = opts.debug;
      for (library in report) {
        contents = report[library];
        console.log("--- Processing ".blue + library.bold + " ---".blue);
        for (i = 0, len = contents.length; i < len; i++) {
          ref = contents[i], folder = ref[0], keep = ref[1], reason = ref[2];
          console.log((keep ? "Keep".green : (actionNeeded = true, "Remove".red)), "\t", path.basename(folder).bold);
          if (reason && verbose && !debug) {
            console.log("\t -> Found", reason.bold);
          }
        }
      }
      if (debug && actionNeeded) {
        files = "";
        for (_ in report) {
          results = report[_];
          for (j = 0, len1 = results.length; j < len1; j++) {
            ref1 = results[j], folder = ref1[0], keep = ref1[1], reason = ref1[2];
            if (!(!keep)) {
              continue;
            }
            files += folder + "\n";
            if (reason && verbose) {
              files += "-> " + reason + "\n";
            }
          }
        }
        console.log(("\n-- START DEBUG INFO --\n" + files + "--  END DEBUG INFO  --").bgYellow.black);
      }
      return fulfill(actionNeeded);
    });
  };

  exports.confirm = function(actionNeeded) {
    return new Promise(function(fulfill) {
      if (!actionNeeded) {
        return fulfill(false);
      }
      process.stdout.write("\n" + "Apply?".bgRed.white + " (Y/n) ");
      return process.stdin.setEncoding("utf8").once("data", function(r) {
        return fulfill((function() {
          switch (r.trim().toLowerCase()) {
            case "":
            case "y":
            case "yes":
              return true;
            case "":
            case "n":
            case "no":
              return false;
            default:
              return exports.confirm();
          }
        })());
      });
    });
  };

  exports.remove = function(arg) {
    var _, files, folder, i, keep, len, opts, ref, report, results;
    opts = arg[0], report = arg[1];
    files = [];
    for (_ in report) {
      results = report[_];
      for (i = 0, len = results.length; i < len; i++) {
        ref = results[i], folder = ref[0], keep = ref[1];
        if (!keep) {
          files.push(folder);
        }
      }
    }
    return trash(files);
  };

}).call(this);
